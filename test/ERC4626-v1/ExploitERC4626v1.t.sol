// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../../src/ERC4626-v1/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MCK") {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;

    function setUp() public {
        token = new MockERC20();
        vault = new VulnerableVault(IERC20(address(token)));
        
        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10**token.decimals());
        token.transfer(victim, 10000 * 10**token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10**token.decimals(), victim);
        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(player);

        // TODO: Exploit the vault here
        // Hint: The vulnerability is in the deposit and withdraw functions
        // Your goal is to drain the victim's funds from the vault

        vm.stopPrank();

        // Check if the exploit was successful
        assertGt(token.balanceOf(player), 10000 * 10**token.decimals(), "Player should have more than 10000 tokens");
        assertLt(token.balanceOf(address(vault)), 1000 * 10**token.decimals(), "Vault should have less than 1000 tokens left");
    }
}
